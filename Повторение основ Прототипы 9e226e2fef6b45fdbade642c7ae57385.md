# Повторение основ. Прототипы

# Что такое прототип?

это внутренняя ссылка, которая существует в одном объекте и ссылается на другой объект.

Эта ссылка используется при обращении к несуществующему свойству/методу первого объекта. В таком случае ссылка `[[Prototype]]` говорит движку, что свойство/метод нужно искать в связанном объекте. В свою очередь, если поиск в этом объекте завершается неудачно, то происходит переход уже по его ссылке `[[Prototype]]` и так далее. Эта последовательность ссылок между объектами образует так называемую "цепочку прототипов".

Наиболее популярный способ связать два объекта друг с другом — использовать ключевое слово `new` с вызовом функции, что создаст новый объект, привязанный к другому объекту, на который указывает свойство `.prototype` функции, вызванной с `new`. 

# Какими способами можно установить прототип объекта?

Foo.prototype = { /* .. */ }; // создаем новый объект-прототип

Bar.prototype = Object.create( Foo.prototype );

Object.setPrototypeOf( Bar.prototype, Foo.prototype );

# Возможно ли наследование от нескольких объектов?

в общем - нет

Объект может иметь только один прототип. Наследование из двух классов может быть выполнено путем создания родительского объекта в виде комбинации двух родительских прототипов.

Синтаксис для подклассификации позволяет сделать это в объявлении, поскольку правая часть предложения `extends` может быть любым выражением. Таким образом, вы можете написать функцию, которая объединяет прототипы в соответствии с любыми критериями, которые вы хотите, и вызывать эту функцию в объявлении класса.

# В чем отличие наследования через Class от наследования через Функции конструкторы?

в упрощенном синтаксисе , хотя 'под капотом' механизм остается прежним
class B extends A{

constructor(){

super()

]

}

function A(){}

functionB(){

A.call(this)

}
B.prototype = Object.create(A.prototype)

# Работает ли цепочка прототипов на запись / удаление свойств?

три сценария присваивания `myObject.foo = "bar"`, когда `foo` **не** содержится непосредственно в `myObject`, а **находится** выше по цепочке `[[Prototype]]` объекта `myObject`:

1. Если обычное свойство доступа к данным (см. главу 3) с именем `foo` находится где-либо выше по цепочке `[[Prototype]]`, **и не отмечено как только для чтения (`writable:false`)**, то новое свойство `foo` добавляется непосредственно в объект `myObject`, и происходит **затенение свойства**.
2. Если `foo` находится выше по цепочке `[[Prototype]]`, но отмечено как **только для чтения (`writable:false`)**, то установка значения этого существующего свойства, равно как и создание затененного свойства у `myObject`, **запрещены**. Если код выполняется в `strict mode`, то будет выброшена ошибка, если нет, то попытка установить значение свойства будет проигнорирована. В любом случае, **затенения не происходит**.
3. Если `foo` находится выше по цепочке `[[Prototype]]` и является сеттером (см. главу 3), то всегда будет вызываться сеттер. Свойство `foo` не будет добавлено в `myObject`, сеттер `foo` не будет переопределен.

Оператор delete удаляет только локальные свойства из объекта. Если наследуемое свойство, которое было записано, удаляется, его значение возвращается к наследуемому значению. Попытка удалить свойство объекта, которое наследуется, не имеет никакого эффекта.

# Как работает доступ через точку у примитивов?

при таком доступе создаётся специальный «объект-обёртка», который предоставляет нужную функциональность, а после удаляется.